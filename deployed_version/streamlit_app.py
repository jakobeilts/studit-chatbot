import os
import json
import pickle
import uuid
import pathlib
from datetime import datetime, timezone
from textwrap import dedent

import streamlit as st
from langchain.chat_models import init_chat_model
from langchain.retrievers import ParentDocumentRetriever
from langchain_community.vectorstores import FAISS
from langchain_text_splitters import RecursiveCharacterTextSplitter
from langgraph.graph import MessagesState, StateGraph, END
from langgraph.prebuilt import ToolNode, tools_condition
from langgraph.checkpoint.memory import MemorySaver
from langchain_core.tools import tool
from langchain_core.messages import SystemMessage, AIMessage
from langchain_core.documents import Document
from typing_extensions import List
import smtplib, ssl, html
from email.message import EmailMessage
from helper.academicCloudEmbeddings import AcademicCloudEmbeddings
st.set_page_config(page_title="StudIT‚ÄëChatbot", page_icon="üí¨", layout="centered")

BASE = pathlib.Path(__file__).parent.resolve()
VECTORSTORE_DIR = BASE / "faiss_child_index"
PARENT_STORE_PATH = BASE / "parent_store.pkl"

# ----------------------------------------------------------------------
# 1.   Logging‚ÄëUtility (ein JSONL‚ÄëEintrag pro Chat‚ÄëNachricht)
# ----------------------------------------------------------------------
LOG_DIR = "chat_logs"
pathlib.Path(LOG_DIR).mkdir(exist_ok=True)

if "chat_id" not in st.session_state:   # UUID je Browser‚ÄëSession
    st.session_state.chat_id = str(uuid.uuid4())

def write_log(role: str, content: str) -> None:
    """H√§ngt eine Zeile {ts, role, content} an die Log‚ÄëDatei der Session an."""
    entry = {
        "ts": datetime.now(timezone.utc).isoformat(),
        "role": role,
        "content": content,
    }
    log_file = os.path.join(LOG_DIR, f"{st.session_state.chat_id}.jsonl")
    with open(log_file, "a", encoding="utf-8") as f:
        f.write(json.dumps(entry, ensure_ascii=False) + "\n")

# ----------------------------------------------------------------------
# 2.   Prompt‚ÄëVorlage f√ºr RAG‚ÄëAntworten
# ----------------------------------------------------------------------
BASE_RULES = dedent("""/no_think
    Du bist der hilfreiche StudIT‚ÄëAssistent der Universit√§t G√∂ttingen.
    ‚Ä¢ Antworte bevorzugt auf Deutsch.
    ‚Ä¢ Antworte so kurz wie m√∂glich, aber so ausf√ºhrlich wie n√∂tig.
    ‚Ä¢ Stelle gezielte R√ºckfragen, wenn Informationen fehlen, die f√ºr eine passende Auswahl oder Handlung unbedingt notwendig sind (z.B. Betriebssystem, Nutzergruppe, Standort).
    ‚Ä¢ Stelle keine R√ºckfragen, wenn der abgerufene Kontext bereits eindeutig beantwortet werden kann.
    ‚Ä¢ Stelle keine hypothetischen oder spekulativen R√ºckfragen ‚Äì orientiere dich nur an den tats√§chlichen Inhalten.
    Was kann in der RAG Datenbank gesucht werden?
    IT- und studIT-Services
    Supportangebote, Beratungszeiten, Standorte, Kontaktm√∂glichkeiten zu studIT (IT-Service f√ºr Studierende und Mitarbeitende).
    Historie von studIT und Entwicklung der IT-Dienste f√ºr Studierende.
    Studierendenaccount & Zugangssysteme
    Alles rund um den Studierendenaccount: Erstellung, Rechte, Passwortverwaltung, Multifaktor-Authentifizierung, Namens√§nderung, Zusammenlegung mit Vorkurs-Accounts, Zugang nach Exmatrikulation.
    Probleme mit dem Account (z.B. Sperrung, Loginprobleme) und deren L√∂sung.
    Nutzungsordnung, Rechte und Pflichten, Datenschutz, rechtliche Rahmenbedingungen.
    E-Mail & Kommunikation
    Anleitungen und Einstellungen zur Nutzung des studentischen E-Mail-Postfachs (Outlook, Thunderbird, Apple Mail, Android/iOS, Webmail).
    Eigenschaften, Speicherbegrenzungen, Spam-Filter, E-Mail-Weiterleitung, Pflichten zur Nutzung der studentischen E-Mail im universit√§ren Kontext.
    Hilfen bei √ºberf√ºlltem Postfach, Sicherheitsaspekte.
    eCampus Portal
    Funktions√ºbersicht des eCampus (zentrales Studierendenportal der Uni G√∂ttingen): Zugang zu UniVZ, FlexNow, Stud.IP, pers√∂nlichen Kalender, Newsfeeds, Portlets etc.
    FAQs, Selfservice-Funktionen (SB-Funktionen), elektronische Formulare (z.B. Pr√ºfungsr√ºcktritt, Fristverl√§ngerung bei Krankheit, Anerkennung von Pr√ºfungsleistungen).
    Verwaltung und Personalisierung der Startseite (Portlets, Registerkarten, Layouts).
    Technikhilfen bei Loginproblemen oder Fehlern.
    Stud.IP & HISinOne EXA
    Nutzung und Zugang zum Lernmanagementsystem Stud.IP und zum Campusmanagementsystem HISinOne EXA (Vorlesungsverzeichnis, Personen-, Raum- und Veranstaltungsverwaltung).
    Zusammenh√§nge, Daten√ºbertragung und Zusammenspiel der Systeme (z.B. UniVZ ‚Üí Stud.IP).
    Studienausweis/Chipkarte
    Funktionen und Ausgabe des Studienausweises (‚ÄûChipkarte‚Äú): Identifikation, Zahlfunktion, Semesterticket, Bibliotheksausweis, Kultursemesterticket, Heimvorteil.
    Vorgehen bei Verlust, Besch√§digung oder Neuausstellung, Sperrung, Verl√§ngerung.
    Besonderheiten bei der R√ºckmeldung, Semesterbeitrag, Immatrikulation, Beurlaubung.
    Drucken, Kopieren, Scannen
    Standorte und Nutzungsm√∂glichkeiten der studIT-PCs, Multifunktionsger√§te, Drucker (Follow-Me Printing, Direktdruck etc.), Kopierer und Scanner.
    Aufladen und Verwalten des Druckguthabens, Preise, R√ºckerstattungen, Freidruckguthaben, √úbertragung von Guthaben.
    Nutzung verschiedener Endger√§te (Windows, MacOS, Linux, Android, iOS, USB-Stick, E-Mail-to-Print).
    Hinweise zu Posterdruck, Sondersoftware (z.B. f√ºr Blinde, Videobearbeitung).
    Netzwerke & Internet
    WLAN-Nutzung auf dem Campus (eduroam, GuestOnCampus, Einwahl f√ºr unterschiedliche Betriebssysteme).
    VPN-Nutzung (inkl. eduVPN, Anleitung und Sicherheitsaspekte, Mehrfaktor-Authentifizierung).
    Hinweise zu Verschl√ºsselung und Netzwerksicherheit.
    Datenspeicherung & -zugriff
    Informationen zu Homeverzeichnis (pers√∂nlicher Speicherplatz), Cloudspeicher (ownCloud), Netzlaufwerkverbindungen mit verschiedenen Betriebssystemen.
    Datensicherung/Backup, technische Anleitungen f√ºr den remote Zugriff (z.B. mit WinSCP, Cyberduck).
    Campussoftware & Zusatzdienste
    Verf√ºgbare Software (Campuslizenzen: Office 365, Citavi, CorelDRAW, Statistik-Programme wie SAS/SPSS/Statistica, ATLAS.ti, MindManager).
    Installationsanleitungen und Support, Zugangsbedingungen, Besonderheiten bei Nutzung auf studIT-PCs und privat.
    Links und Beschreibungen zu Angeboten f√ºr Forschung und Lehre.
    Raum- und Schlie√üfachreservierung (LSG/SUB)
    Anleitung und Bedingungen f√ºr die Reservierung von Arbeitsr√§umen und Schlie√üf√§chern √ºber eCampus/mobile Apps.
    Punktesystem, Einladung von Kommiliton:innen, Verwaltung, Stornierung.
    Bibliotheksdienste/SUB
    PCs und Internetzugang in der SUB/Bibliotheken, Nutzung als Studierende:r und Gast.
    Nutzung von Buchscannern, Spezialscannern, Kopier- und Druckkonten f√ºr Privatnutzer:innen.
    Kurse & Weiterbildung
    Angebot und Anmeldung zu ZESS-IT-Kursen f√ºr den Erwerb von Computerkenntnissen (z.B. Office, Grafikprogramme, HTML/CSS).
    Hinweise zur Anerkennung im Studium, Pr√ºfungen und Credit Points.
    UniBlogs
    Informationen zu den Uni G√∂ttingen Blogs f√ºr Studierende, Alumni, Lehrende und Organisationen: Anmeldung, Gestaltung, Nutzung von Plugins und Themes, Medienverwaltung.
    Glossar und Begriffserkl√§rungen
    Bedeutungs- und Begriffserkl√§rungen zu IT-relevanten und universit√§ren Begriffen (z.B. LRC, FlexNow, Chipkarte, Homeverzeichnis, eduroam, VPN).
    Datenschutz & rechtliche Hinweise
    Datenschutzerkl√§rungen gem√§√ü DSGVO, Pflichtangaben, Ablauffristen f√ºr Speicherungen und Rechte betroffener Personen.
    Links und Hinweise zu offiziellen Ordnungen, Benutzungsordnungen.
    ‚Ä¢ Wenn eine Anleitung mehrere Varianten f√ºr unterschiedliche Betriebssysteme enth√§lt und das Betriebssystem nicht genannt ist, MUSST du zuerst das Tool `ask` mit einer R√ºckfrage nach dem Betriebssystem aufrufen, bevor du das Tool `retrieve` nutzt.
    ‚Ä¢ Verwende `retrieve` erst, nachdem du die notwendige Spezifizierung erhalten hast (z.‚ÄØB. Betriebssystem, Ger√§tetyp).
    ‚Ä¢ Wenn du eine fachliche Frage beantwortest, RUFE IMMER zuerst das Tool `retrieve` auf und beantworte erst dann. Antworte niemals mit Fakten aus anderen Quellen.
    ‚Ä¢ Falls keine relevante Information gefunden wird, verweise auf offizielle Kontakte (z.B. Link oder E‚ÄëMail).
    ‚Ä¢ Alle Fragen beziehen sich auf die Georg-August-Universit√§t G√∂ttingen.
    HALLUZINIERE NICHT.\n""")

# ----------------------------------------------------------------------
# 3.   Vektor‚ÄëDatenbank + LLM‚ÄëInstanz
# ----------------------------------------------------------------------

embedder = AcademicCloudEmbeddings(
    api_key=st.secrets["GWDG_API_KEY"],
    url=st.secrets["BASE_URL_EMBEDDINGS"],
)

vector_store = FAISS.load_local(
    str(VECTORSTORE_DIR),
    embedder,
    allow_dangerous_deserialization=True,
)

# load parent doc-store
with open(PARENT_STORE_PATH, "rb") as f:
    parent_store = pickle.load(f)

# re-create the *same* splitter used at index time
splitter = RecursiveCharacterTextSplitter(
    chunk_size    = 1000,
    chunk_overlap = 200,
    separators    = ["\n\n", "\n", " ", ""],
)
# retriever to use everywhere
retriever = ParentDocumentRetriever(
    vectorstore    = vector_store,
    docstore       = parent_store,
    child_splitter = splitter,
    search_kwargs  = {"k": 4},
)

llm = init_chat_model(
    "qwen3-32b",
    model_provider="openai",
    base_url=st.secrets["BASE_URL"],
    temperature=0.3,
    api_key=st.secrets["GWDG_API_KEY"],
    extra_body={"chat_template_kwargs": {"enable_thinking": False}},
)

# ----------------------------------------------------------------------
# 4.   LangGraph‚ÄëState + Retrieval‚ÄëTool
# ----------------------------------------------------------------------
class State(MessagesState):
    context: List[Document] # f√ºr sp√§tere Anzeige der Quellen
    asked: bool = False  # ob eine R√ºckfrage gestellt wurde
    current_tool_docs: List[Document] = [] # f√ºr sp√§tere Anzeige der Quellen

@tool(response_format="content_and_artifact")
def retrieve(query: str):
    """Sucht passende Wiki‚ÄëDokumente per FAISS und liefert sie zur√ºck."""
    docs = retriever.get_relevant_documents(query)
    print(f"\nüìÑ RETRIEVED CONTEXTS  (k={len(docs)})")
    for i, d in enumerate(docs, 1):
        print(f"\n‚îÄ‚îÄ‚îÄ DOC {i} ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ")
        print("metadata:", json.dumps(d.metadata, ensure_ascii=False, indent=2))
        print("content:\n", d.page_content)
    serialized = "\n\n".join(
        (f"Source: {d.metadata}\nContent: {d.page_content}") for d in docs
    )
    return serialized, docs

@tool(response_format="content")
def ask(missing_info: str) -> str:
    """Stellt eine gezielte R√ºckfrage an den Nutzer, wenn Informationen fehlen."""
    return f"Ich brauche noch folgende Information, um weiterzumachen: {missing_info}"


def query_or_respond(state: State):
    """Erster LLM-Aufruf: pr√ºft, ob ein Tool n√∂tig ist."""
    messages = [SystemMessage(BASE_RULES)] + state["messages"]
    resp = llm.bind_tools([retrieve, ask]).invoke(messages)
    return {"messages": [resp]}



tools = ToolNode([retrieve, ask])


def generate(state: State):
    """Zweiter LLM-Aufruf: nutzt Kontext und gibt finale Antwort."""
    # 1. Dokumente aus Tools sammeln
    recent_tool_msgs = [m for m in reversed(state["messages"]) if m.type == "tool"]
    ctx_blocks = "\n\n".join(m.content for m in recent_tool_msgs)

    # 2. Basis-Prompt
    messages = [SystemMessage(BASE_RULES)]

    # 3. Kontext als separate Assistant-Message hinzuf√ºgen
    # 3. Kontext als separate Assistant‚ÄëMessage hinzuf√ºgen
    if ctx_blocks:
        messages.append(
            AIMessage(content=f"""
                        Antworte **ausschlie√ülich basierend auf den folgenden Ausschnitten**.
                        Nutze m√∂glichst w√∂rtliche Formulierungen und gib **keine Informationen wieder**, die **nicht explizit** in den Abschnitten genannt werden. 
                        **Erfinde keine zus√§tzlichen Informationen.**
                        Hier sind die kontextuellen Abschnitte:

                        {ctx_blocks}
                        """)
        )

    # 4. Gespr√§chsverlauf (Human + AI‚ÄëTurns OHNE Tool‚ÄëCalls)
    for m in state["messages"]:
        if m.type == "human":
            messages.append(m)
        elif m.type == "ai" and not getattr(m, "tool_calls", None):
            messages.append(m)

    # 5. Finaler Aufruf
    resp = llm.invoke(messages)

    # 6. Dokumente speichern
    ctx_docs = []
    for tm in reversed(state["messages"]):
        if tm.type == "tool":
            artifacts = getattr(tm, "artifact", None)
            if artifacts:
                ctx_docs.extend(artifacts)
            break  # Nur den letzten Tool-Call verwenden

    return {"messages": [resp], "context": ctx_docs, "current_tool_docs": ctx_docs}


# ----------------------------------------------------------------------
# 5.   Graph‚ÄëDefinition (Query ‚Üí ggf. Tool ‚Üí Answer)
# ----------------------------------------------------------------------
@st.cache_resource(show_spinner="Initialisiere Modelle‚Ä¶")
def build_graph():
    g = StateGraph(State)
    g.add_node(query_or_respond)
    g.add_node(tools)

    def tool_decider(state: State):
        tool_msg = [m for m in state["messages"] if m.type == "tool"]
        if not tool_msg:
            return END

        last_tool = tool_msg[-1].name

        if last_tool == "retrieve":
            return "generate"

        elif last_tool == "ask":
            if state.get("asked"):  # Schon gefragt ‚Üí abbrechen
                return END
            else:
                state["asked"] = True
                return END  # War erste Frage ‚Üí auf Antwort warten
        return END

    g.add_node(generate)

    g.set_entry_point("query_or_respond")
    g.add_conditional_edges(
        "query_or_respond",
        tools_condition,
        {
            END: END,
            "tools": "tools",
        },
    )
    g.add_conditional_edges("tools", tool_decider, {"generate": "generate", END: END})
    g.add_edge("generate", END)

    return g.compile(checkpointer=MemorySaver())  # MemorySaver = Zustands‚ÄëCache

graph = build_graph()
config = {"configurable": {"thread_id": "abc123"}}

# ----------------------------------------------------------------------
# 6.   Streamlit‚ÄëUI
# ----------------------------------------------------------------------
st.title("StudIT‚ÄëChatbot")
st.logo("helper/images/uni_logo.png")

# ----------------------------------------------------------
# Einmalige Willkommens‚ÄëNachricht (nicht im Verlauf speichern)
# ----------------------------------------------------------
with st.chat_message("assistant"):
    st.markdown(
        "Hallo und willkommen beim **StudIT‚ÄëChatbot**! "
        "Stell mir gerne deine Frage rund um IT‚ÄëServices an der Universit√§t G√∂ttingen."
        "Sollte ich eine Frage nicht beantworten k√∂nnen oder deine Anfrage noch mehr Service ben√∂tigt als ich leisten kann, kannst du auch direkt √ºber den \"Support-Ticket √∂ffnen\" Button ein Ticket an den Support schreiben."
    )

# Session‚ÄëState‚ÄëInitialisierung
for key, default in {
    "messages": [],
    "support_form_visible": False,
    "support_summary": "",
    "support_full_chat": "",
}.items():
    st.session_state.setdefault(key, default)

# Bisherige Chat‚ÄëNachrichten anzeigen
for m in st.session_state.messages:
    with st.chat_message(m["role"]):
        st.markdown(m["content"])

# ----------------------------------------------------------
# Nutzer‚ÄëEingabe ‚Üí Graph ‚Üí Antwort
# ----------------------------------------------------------
if user_input := st.chat_input("Frag mich etwas ‚Ä¶",  key="main_chat"):
    print(f"\nüü¢ USER ‚Üí {user_input}")
    # 1) Nutzer‚ÄëNachricht speichern + loggen
    st.session_state.messages.append({"role": "user", "content": user_input})
    write_log("user", user_input)
    with st.chat_message("user"):
        st.markdown(user_input)

    # 2) Graph ausf√ºhren
    with st.spinner("Denke nach‚Ä¶"):
        result = graph.invoke({"messages": st.session_state.messages}, config=config)

    # 3) Antwort speichern + loggen
    ai_msg = result["messages"][-1].content
    print("\nü§ñ BOT ‚Üê\n", ai_msg)
    st.session_state.messages.append({"role": "assistant", "content": ai_msg})
    write_log("assistant", ai_msg)
    with st.chat_message("assistant"):
        st.markdown(ai_msg)

    ######################################################################
    #  ### NEW CODE: build & store the compact RAG report  ###############
    ######################################################################
    # Gather up to 4 retrieved passages (already limited to k=4)
    retrieved_contexts = [
        doc.page_content if hasattr(doc, "page_content") else doc.get("page_content", "")
        for doc in result.get("current_tool_docs", [])
    ]

    # Build the JSON object
    rag_report = {
        "user_input": user_input,  # already have it
        "reference": "",  # fill in if you have a gold answer
        "retrieved_contexts": retrieved_contexts,
        "response": ai_msg,
    }

    # Decide what you want to do with it ‚Äì here we append to a second log file
    rag_log_file = os.path.join(LOG_DIR, f"EVAL_{st.session_state.chat_id}_rag.jsonl")
    print("‚ñ∫ Saving RAG log‚Ä¶")
    print(json.dumps(rag_report, ensure_ascii=False, indent=2))
    ######################################################################

    # 4) Quellen‚ÄëExpander
    if result.get("current_tool_docs"):
        st.markdown("### Quellen & Ausschnitte")

        seen_sources = set()

        for doc in result["current_tool_docs"]:
            meta = doc.metadata if hasattr(doc, "metadata") else doc.get("metadata", {})
            text = doc.page_content if hasattr(doc, "page_content") else doc.get("page_content", "")
            source = meta.get("url") or meta.get("source") or "Unbekannte Quelle"

            if source in seen_sources:
                continue
            seen_sources.add(source)

            with st.expander(source):
                st.markdown(f"[Zur Quelle]({source})")
                st.markdown(f"> {text[:400]}‚Ä¶")

# ----------------------------------------------------------
# Support‚ÄëTicket‚ÄëButton (immer sichtbar)
# ----------------------------------------------------------
if st.button("Support‚ÄëTicket √∂ffnen"):
    # Vollst√§ndigen Chat dumpen
    chat_dump = "\n".join(f"{m['role'].title()}: {m['content']}"
                          for m in st.session_state.messages)
    st.session_state.support_full_chat = chat_dump

    # 2‚Äë3‚ÄëSatz‚ÄëSummary via LLM (oder leer, falls noch kein Chat)
    if st.session_state.messages:
        summary_prompt = (
            "Fasse den folgenden Dialog zwischen einem Nutzer und dem StudIT‚ÄëChatbot "
            "in 2‚Äë3 S√§tzen zusammen:\n\n"
            f"{chat_dump}"
        )
        st.session_state.support_summary = llm.invoke(summary_prompt).content.strip()
    else:
        st.session_state.support_summary = ""

    st.session_state.support_form_visible = True

# ----------------------------------------------------------------------
# E-Mail Versand
# ----------------------------------------------------------------------
def send_support_mail(subject: str, plain_body: str, html_body: str | None = None) -> None:
    """Versendet Plain‚ÄëText + optional HTML an SUPPORT_TO."""
    cfg = st.secrets["EMAIL"]

    msg = EmailMessage()
    msg["Subject"] = subject
    msg["From"]    = cfg["SMTP_USER"]
    msg["To"]      = cfg["SUPPORT_TO"]
    msg.set_content(plain_body)                 # Fallback‚ÄëTeil

    if html_body:                               # h√ºbsche Variante
        msg.add_alternative(html_body, subtype="html")

    server, port = cfg["SMTP_SERVER"], int(cfg["SMTP_PORT"])

    if port == 465:  # SMTPS
        context = ssl.create_default_context()
        with smtplib.SMTP_SSL(server, port, context=context) as smtp:
            smtp.login(cfg["SMTP_USER"], cfg["SMTP_PASS"])
            smtp.send_message(msg)
    else:            # STARTTLS (Port 587 bei WEB.DE zum Beispiel)
        context = ssl.create_default_context()
        with smtplib.SMTP(server, port) as smtp:
            smtp.starttls(context=context)
            smtp.login(cfg["SMTP_USER"], cfg["SMTP_PASS"])
            smtp.send_message(msg)


# ----------------------------------------------------------------------
# Support‚ÄëFormular (wird per State‚ÄëFlag angezeigt)
# ----------------------------------------------------------------------
def support_form() -> None:
    st.subheader("Support‚ÄëAnfrage")

    name  = st.text_input("Name",  value=st.session_state.get("support_name",  ""))
    email = st.text_input("E‚ÄëMail", value=st.session_state.get("support_email", ""))

    chat_exists = bool(st.session_state.messages)
    addition_label = "Anliegen" if not chat_exists else "Optional: Erg√§nze dein Anliegen"
    addition = st.text_area(addition_label, height=100)

    if st.button("Supportanfrage absenden"):
        # Basis‚ÄëValidierung
        errors = []
        if not name.strip():  errors.append("Name darf nicht leer sein.")
        if not email.strip(): errors.append("E‚ÄëMail‚ÄëAdresse darf nicht leer sein.")
        if not chat_exists and not addition.strip():
            errors.append("Bitte gib dein Anliegen ein.")
        if errors:
            for err in errors:
                st.error(err)
            return

        # Mail‚ÄëPreview zusammenbauen
        chat_dump = "\n".join(f"{m['role'].title()}: {m['content']}"
                              for m in st.session_state.messages)
        summary = st.session_state.support_summary or addition.strip()

        full_msg = (
            "Hallo StudIT‚ÄëTeam,\n\n"
            "folgende Anfrage stammt aus dem FAQ‚ÄëChatbot:\n\n"
            f"{summary}\n\n\n"
            "Zus√§tzliche Nachricht des Nutzers/der Nutzerin:\n\n"
            f"{addition.strip()}\n\n\n"
            "Vollst√§ndiger Chatverlauf:\n"
            f"{chat_dump}"
        )

        # ‚Ä¶ innerhalb der support_form(), direkt vor send_support_mail():
        plain_msg = full_msg  # schon vorbereitet

        # Zeilenumbr√ºche ‚Üí <br>, bevor man in den f‚ÄëString geht
        summary_html = html.escape(summary).replace("\n", "<br>")
        addition_html = html.escape(addition).replace("\n", "<br>")
        chat_html = html.escape(chat_dump)  # pre‚Äëescaped; <pre> beh√§lt \n

        html_msg = f"""
        <!DOCTYPE html>
        <html>
          <body style="font-family:sans-serif; line-height:1.5;">
            <h2 style="color:#1a4180;">StudIT‚ÄëSupportanfrage</h2>

            <p><strong>Von:</strong> {html.escape(name)} &lt;{html.escape(email)}&gt;</p>

            <h3 style="margin-bottom:4px;">Kurzzusammenfassung</h3>
            <p>{summary_html}</p>

            <h3 style="margin-bottom:4px;">Zus√§tzliche Nachricht</h3>
            <p>{addition_html or "- (keine) -"}</p>

            <h3 style="margin-bottom:4px;">Vollst√§ndiger Chat</h3>
            <pre style="
                 background:#f4f6fa;
                 padding:10px 14px;
                 border:1px solid #dce0e6;
                 border-radius:6px;
                 white-space:pre-wrap;
                 font-family:SFMono-Regular,Consolas,monospace;
            ">{chat_html}</pre>
          </body>
        </html>
        """

        try:
            send_support_mail("Chatbot‚ÄëSupportanfrage", plain_msg, html_msg)
            st.info("E‚ÄëMail wurde versendet.")
        except Exception as e:
            st.error(f"E‚ÄëMail‚ÄëVersand fehlgeschlagen: {e}")

        st.success("Support‚ÄëAnfrage vorbereitet (E‚ÄëMail‚ÄëVersand folgt).")
        st.markdown("### Vorschau")
        st.markdown(f"**Name:** {name}")
        st.markdown(f"**E‚ÄëMail:** {email}")
        st.markdown("**Nachricht an StudIT:**")
        st.markdown(full_msg)

        # Persistente Werte speichern & Formular schlie√üen
        st.session_state.update(
            support_form_visible=False,
            support_name=name,
            support_email=email,
            support_addition=addition,
        )

if st.session_state.get("support_form_visible"):
    support_form()
